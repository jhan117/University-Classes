# Chapter 2 부울 대수와 부울 함수

1. 부울 대수(Boolean algebra)
   - 공리와 정리
     - 공리: 증명 필요 x
     - 정리: 증명 필요 o
   - 전체 공리와 정리
     1. 닫힘: 부울 대수는 두 연산 `+` 및 `·` 에 대해 닫혀 있다.
     2. 부울 대수의 두 연산은 결합법칙과 교환법칙이 성립한다.
     3. `+` 연산의 항등원은 0이며, `·` 연산의 항등원은 1이다.
     4. x + x' = 1, x · x' = 1 이 식을 만족하는 x의 보수 x'이 존재한다.
     5. 두 연산은 분배 법칙이 성립한다.
2. 부울 대수의 요약과 특징
   - 이원성 원리: 리터럴 유지, 연산자와 2진 상수 서로 바뀜
   - 드모르간 법칙: 리터럴 부정, 영산자와 2진 상수 서로 바뀜
   - 정리 추가
     - 항등원 확장1: x + 1 = 1, x · 0 = 0
     - 항등원 확장2: x + x = x, x · x = x
     - 흡수: x + (x · y) = x, x · (x + y) = x
     - 드모르간 법칙: (x + y)' = x' · y', (x · y)' = x' + y'
     - 보수 확장(이중 보수): (x')' = x
3. 부울 함수
   - 논리식: 2진 상수, 리터럴, 2개의 연산자
   - 부울 함수: 리터럴, 연산자
     - `F(x, y) = x + y`
     - x, y : 인자
   - 진리표: 나타날 수 있는 모든 입력 변수(리터럴)에 대해 결과가 유일하게 표로 표현됨
   - 연산자
     - XOR: ⊕
     - XNOR: ⊙
4. 부울 함수 표현 방식
   - SOP와 POS
     - 기본 형식: 간소화
     - 표준 형식: 모든 리터럴 표현
     - SOP, 곱의 합, 최소항의 합(AND-OR): ∑m_i
     - POS, 합의 곱, 최대항의 곱(OR-AND): ∏m_i
     - 최소항과 최대항의 변환관계
       - F(x, y) = ∑(1, 2, 3) = ∏(0)
     - 항상 2단계 게이트 군으로 형성되므로 회로를 2-단계 구현이라고 부름.
5. 2-변수 부울 함수와 부수적 연산
   - 부수적 논리 연산자
     - logic-0: 결과가 항상 0, 전원의 접지(출력판을 접지와 연결), ground or earth
     - logic-1: 결과가 항상 1, 전원의 바이어스(+) 전압(보통 +5V, +전원에 연결)
     - AND: xy, OR: x + y
       - 암기법:
         - OR: 하나라도 1이면 OK +(덧셈)
         - AND: 모두 1이어야 OK x(곱셈)
     - XOR: x ⊕ y, XNOR: x ⊙ y
     - NAND: (xy)' = (x' + y'), NOR: (x + y)' = x'y'
     - 버퍼: 그대로, 인버터: 보수
     - 금지(inhibition) 연산: x'y, xy'
       - y/x: x를 제어 입력으로 설정 x = 1이면 무조건 출력이 0
       - x/y: y를 제어 입력으로 설정 y = 1이면 무조건 출력이 0
       - 제어 입력이 0이면 다른 입력을 출력함
       - 0 또는 다른 입력 출력
     - 함의(implication) 연산: x' + y, x + y'
       - x -> y(x ⊃ y)
       - y -> x(y ⊃ x)
       - 선행자가 0이면 결과는 무조건 1
       - 선행자가 1이면 결과는 후행자 출력
       - 1 또는 다른 입력 출력
   - 만능 게이트
     - NAND -> 인버터, AND, OR 구현 가능
     - NOR -> 인버터, AND, OR 구현 가능
   - 게이트 입력 확장
     - 다중 입력 게이트 설계 가능: AND, OR, XOR, XNOR
       - XOR 연산: 1의 개수가 홀수인 기함수
       - XNOR 연산: 1의 개수가 짝수인 우함수
     - 불가능: NAND, NOR => AND, OR을 확장해서 인버터 추가해 구현을 하는 것이 좋다
6. XOR 연산의 활용
   - 패리티 검사
     - 근거리인 경우: 재전송이 쉬워서 오류 검출
     - 원거리인 경우: 재전송이 어려워서 오류 수정
     - 근거리 내부 통신인 경우 1-비트 오류 많음
       - 해밍 코드로 효율적으로 오류 수정 가능
     - 보편적인 통신 환경에서는 다발성 오류가 많음
       - 순환 중복 검사(CRC) 기법을 이용: 다항식을 나눈 나머지를 끝에 붙여서 전송한 후 비교함
     - 패리티 비트: 오류를 감지하거나 수정하기 위해서 추가되는 비트 = P = XOR 연산 사용
     - 패리티 검사: 이 비트들을 검사하는 것
     - 검출 비트: D = 메시지 코드 ⊕ P
       - 1이면 오류 발생 감지
       - 0이면 오류 없음
   - 해밍 코드
     - 패리티 비트를 2^n 자리 위치에 배치
       - 항상 유일한 1이 위치한 자리임
       - P_i = 2진수의 i번째 자리가 1인 메시지 위치를 전부 XOR 연산함
     - 메시지 + 패리티 비트가 가능한 데이터만 생성함
     - C_1 = P_1 ⊕ P_1에 해당하는 메시지 코드들 XOR 연산
     - 수정 위치: C_8C_4C_2C_1를 2진수 그대로 읽으면 됨
